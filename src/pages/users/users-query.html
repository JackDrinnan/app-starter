<!-- <link rel="import" href="../../../bower_components/geofire-elements/geofire-query.html"> -->
<!-- <link rel="import" href="../../../bower_components/geo-query-input/geo-query-input.html"> -->
<link rel="import" href="../../../bower_components/geo-location/geo-location.html">
<link rel="import" href="../../../bower_components/geo-codec/geo-codec.html">
<link rel="import" href="../../../bower_components/paper-button/paper-button.html">
<link rel="import" href="/src/header.html">
<link rel="import" href="geofire-query.html">
<link rel="import" href="geo-query-input.html">

<dom-module id="users-query">
<template>
  <style include="app-styles">
    :host {
      display: block;
    }
    geo-query-input {
      border-bottom: 1px solid var(--divider-color);
      padding: 0;
    }
    .summary {
      margin: 4px 8px;
      padding: 4px 8px;
    }
  </style>
  <geo-location idle$="[[!useCurrentLocation]]" latitude="{{userLat}}" longitude="{{userLng}}"></geo-location>
  <geo-codec id="codec" api-key="AIzaSyAUPOaJubJnaRTPUd_xX8MOA62gRtSlfCc"></geo-codec>

  <geofire-query
    geofire="[[geofire]]"
    lat="[[lat]]"
    lng="[[lng]]"
    radius="[[radiusKm]]"
    results-array="{{geoUsers}}"></geofire-query>

    <div class="layout vertical center">
      <geo-query-input
        use-current-location$="{{useCurrentLocation}}"
        radius="1000"
        radius-options="[[radiusOptions]]"
        on-query-changed="_queryChanged"></geo-query-input>
    </div>
    <div class="summary layout horizontal center justified">
      <span>[[_summary(geoUsers, geoUsers.length)]]</span>
      <paper-button disabled$="[[!auth]]" raised class="primary-button" on-tap="_addUser">Add Me</paper-button>
    </div>
</template>
<script>
class UsersQuery extends Polymer.Element {
  static get is() { return 'users-query'; }
  static get config() {
    return { /* properties, observers meta data */
      properties: {
        app: {
          type: Object,
          value: null,
          observer: '_appChanged'
        },
        auth: Object,
        geofire: {
          type: Object,
          value: null
        },

        lat: {
          type: Number,
          notify: true
        },
        lng: {
          type: Number,
          notify: true
        },
        radiusKm: {
          type: Number,
          notify: true
        },
        radiusOptions: {
          type: Array,
          value: function() { return [1000, 5000, 10000, 15000]; }
        },
        geoUsers: {
          type: Array,
          notify: true,
          observer: '_geoUsersChanged'
        },
        profiles: {
          type: Array,
          notify: true
        }
      },
      observers: [
        '_userLocationChanged(userLat, userLng)'
      ]
    }
  }
  constructor() {
    super();
    this.useCurrentLocation = false;
  }
  connectedCallback() {
    super.connectedCallback();
  }

  _appChanged(app, old) {
    if (app && !old) {
        LOG && log.d('Initializing geofire');
        this.geofire = new GeoFire(db.ref('geoUsers'));
    }
  }

  _geoUsersChanged(geoUsers, old) {
    LOG && log.v('geoUsers changed', geoUsers);
    this.profiles = [];

    if (isEmpty(geoUsers)) return;

    for (var i = 0; i < geoUsers.length; i++) {
      this._loadProfile(geoUsers[i], i);
    }
  }

  _loadProfile(geoUser, index) {
    db.watch('/profiles/' + geoUser.key, function(profile) {
      profile.$key = geoUser.key;
      profile.distance = kmToMiles(geoUser.distance);
      LOG && log.v('setting profile index', index, profile);
      this.set('profiles.' + index, profile);
      // TODO can result in incorrect order.
      // this.push('profiles', profile);
      // TODO uses correct order, but issues with notifying changes
      // var profiles = this.profiles;
      // profiles[index] = profile;
      // this.profiles = [];
      // this.profiles = profiles;
    }.bind(this));
  }

  _queryChanged(e, data) {
    LOG && log.v('Query changed', data);
    this.radiusKm = data.radiusKm;
    if (data.useCurrentLocation) {
      this.lat = this.userLat;
      this.lng = this.userLng;
      if (this.addingUser) this._doAddUser();
    } else {
      this.cache = this.cache || {};
      var cached = this.cache[data.location];
      if (!cached) {
        LOG && log.v('geocoding', data.location);
        this.$.codec.geocode(data.location, function (address, lat, lng, place) {
          LOG && log.v(address, lat, lng);
          this.lat = lat;
          this.lng = lng;
          this.cache[data.location] = [address, lat, lng, place];
        }.bind(this));
      } else {
        LOG && log.v('Using cached result', cached);
        this.lat = cached[1];
        this.lng = cached[2];
      }
    }
  }

  _userLocationChanged(userLat, userLng) {
    if (this.useCurrentLocation) {
      this.lat = userLat;
      this.lng = userLng;
    }
  }

  _summary(geoUsers, len) {
    len = len || '~';
    return len + (len == 1 ? ' result.' : ' results.');
  }

  _addUser() {
    this.addingUser = true;
    if (!this.useCurrentLocation) {
      this.useCurrentLocation = true;
    } else if (this.userLat && this.userLng) {
      this._doAddUser();
    }
  }

  _doAddUser() {
    var lat = perturbCoordinate(this.userLat);
    var lng = perturbCoordinate(this.userLng);
    var dist = GeoFire.distance([this.userLat, this.userLng], [lat, lng]);
    LOG && log.v('Anonymizing to', dist, 'km away.');
    db.users.updateLocation(this.auth.uid, lat, lng, null, showServerErrorToast);
    this.addingUser = false;
  }
}
// Register custom element definition using standard platform API
customElements.define(UsersQuery.is, UsersQuery);
</script>
</dom-module>
