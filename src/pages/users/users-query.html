<!-- <link rel="import" href="../../../bower_components/geofire-elements/geofire-query.html"> -->
<!-- <link rel="import" href="../../../bower_components/geo-query-input/geo-query-input.html"> -->
<link rel="import" href="../../../bower_components/geo-location/geo-location.html">
<link rel="import" href="../../../bower_components/geo-codec/geo-codec.html">
<link rel="import" href="/src/header.html">
<link rel="import" href="geofire-query.html">
<link rel="import" href="geo-query-input.html">

<dom-module id="users-query">
<template>
  <style include="app-styles">
    :host {
      display: block;
    }
    geo-query-input {
      border-bottom: 1px solid var(--divider-color);
      padding: 0;
    }
    .summary {
      margin: 4px 8px;
      padding: 4px 8px;
    }
  </style>
  <geo-location latitude="{{userLat}}" longitude="{{userLng}}"></geo-location>
  <geo-codec id="codec" api-key="AIzaSyAUPOaJubJnaRTPUd_xX8MOA62gRtSlfCc"></geo-codec>

  <geofire-query
    geofire="[[geofire]]"
    lat="[[lat]]"
    lng="[[lng]]"
    radius="[[radiusKm]]"
    results-array="{{geoUsers}}"></geofire-query>

    <div class="layout vertical center">
      <geo-query-input
        use-current-location$="[[_hasUserLoc(userLat, userLng)]]"
        radius="1000"
        radius-options="[[radiusOptions]]"
        on-query-changed="_queryChanged"></geo-query-input>
    </div>
    <div class="summary">
      [[_summary(geoUsers, geoUsers.length)]]
    </div>
</template>
<script>
class UsersQuery extends Polymer.Element {
  static get is() { return 'users-query'; }
  static get config() {
    return { /* properties, observers meta data */
      properties: {
        app: {
          type: Object,
          value: null,
          observer: '_appChanged'
        },
        geofire: {
          type: Object,
          value: null
        },

        lat: {
          type: Number,
          notify: true
        },
        lng: {
          type: Number,
          notify: true
        },
        radiusKm: {
          type: Number,
          notify: true
        },
        radiusOptions: {
          type: Array,
          value: function() { return [1000, 5000, 10000, 15000]; }
        },
        geoUsers: {
          type: Array,
          notify: true,
          observer: '_geoUsersChanged'
        },
        profiles: {
          type: Array,
          notify: true
        },
      }
    }
  }
  constructor() {
    super();
  }
  connectedCallback() {
    super.connectedCallback();
  }

  _appChanged(app, old) {
    if (app && !old) {
      // setTimeout(function() {
        LOG && log.d('Initializing geofire');
        this.geofire =  new GeoFire(db.ref('geoUsers'));
      // }.bind(this), 3000);
    }
  }

  _hasUserLoc(userLat, userLng) {
    return false;
    // return userLat && userLng;
  }

  _geoUsersChanged(geoUsers, old) {
    LOG && log.v('geoUsers changed', geoUsers);
    this.profiles = [];

    if (isEmpty(geoUsers)) return;

    for (var i = 0; i < geoUsers.length; i++) {
      this._loadProfile(geoUsers[i], i);
    }
  }

  _loadProfile(geoUser, index) {
    db.watch('/profiles/' + geoUser.key, function(profile) {
      profile.$key = geoUser.key;
      profile.distance = kmToMiles(geoUser.distance);
      LOG && log.v('setting profile index', index, profile);
      this.set('profiles.' + index, profile);
      // TODO can result in incorrect order.
      // this.push('profiles', profile);
      // TODO uses correct order, but issues with notifying changes
      // var profiles = this.profiles;
      // profiles[index] = profile;
      // this.profiles = [];
      // this.profiles = profiles;
    }.bind(this));

    db.ref().on('value', function(snap) {
      var post = snap.val();
      post.$key = result.key;
      post.isRequest = result.isRequest;
      // TODO support metric
      post.distance = kmToMiles(result.distance);




    }.bind(this));
  }

  _queryChanged(e, data) {
    console.log('Query changed', data);
    this.radiusKm = data.radiusKm;
    if (data.useCurrentLocation) {
      this.lat = this.userLat;
      this.lng = this.userLng;
    } else {
      this.cache = this.cache || {};
      var cached = this.cache[data.location];
      if (!cached) {
        LOG && log.v('geocoding', data.location);
        this.$.codec.geocode(data.location, function (address, lat, lng, place) {
          LOG && log.v(address, lat, lng);
          this.lat = lat;
          this.lng = lng;
          this.cache[data.location] = [address, lat, lng, place];
        }.bind(this));
      } else {
        this.lat = cached[1];
        this.lng = cached[2];
      }
    }
  }

  _summary(geoUsers, len) {
    if (len === undefined || len === null) {
      return '';
    }
    return len + (len == 1 ? ' result.' : ' results.');
  }
}
// Register custom element definition using standard platform API
customElements.define(UsersQuery.is, UsersQuery);
</script>
</dom-module>
